## 缓存

缓存的影子无处不再, 例如在存储硬件设备中, 每个上层都是下一层的缓存(CPU 内部的缓存 <- 内存, 内存 <- 硬盘). 为什么需要缓存呢? 这是基于一个理论 `时间局限性, 空间局限性`.  时间局限性: 对于访问到的数据,将在不久之后还会在访问到. 空间局限性: 对于访问到的数据, 它周围的数据也会被访问到

除此之外, 每层存储之间的时间差异大,有天上一日(1级缓存), 人间一年(内存)的说法, 

## 缓存面临的挑战

## 缓存穿透
一般的缓存系统，都是按照`key`去缓存查询，如果不存在对应的`value`，就应该去后端系统查找（比如DB). 但如果存在恶意的人, 通过大量伪造一些不存在的`key`, 访问该系统, 就会造成性能问题.


解决:
1. 因为查询的结果为空, 才让黑客钻了空子. 我们可以对这些`key`返回`value = null`, 同时缓存起来,就有限解决了.但注意要给这些`key`设置过期时间
2. 通过`BloomFilter`, 布隆过滤器. 当流量到达时, 先访问布隆过滤器, 如果发现key不存在, 直接访问null. 如果存在, 在进入到缓存.(相当于在缓存层前加了一道措施)

选择:
两者的适用不同, 如果该系统中`不存在的key`的范围比较大, 而且重复率低, 使用后者. 如果key有限,且重复率高,可以使用前者.

## 缓存击穿
在redis中, 我们一般会对缓存的数据设置一个过期值, 如果某个key为热点流量, 当大量的流量涌进且key的时间正好失效时, 我们称作 **缓存击穿**

解决:
因为大量的流量都是访问这个key, 我们可以设置个`互斥锁(mutex)`, 保证了只有一个线程能访问到DB端, 其他会被阻塞. 当该线程存入新的缓存值时, 释放锁, 其他线程就可以通过缓存值而避免再次访问DB端了

## 缓存雪崩
雪崩: 原本好好的, 突然一下子全炸了. 
比如缓存服务器突然宕机. 
![雪崩](https://user-gold-cdn.xitu.io/2019/3/27/169bb265aa52e948?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

- 事前: 对缓存服务器设置主备或郭可用
- 事中: 本地缓存 + 限流&降级
- 事后: 开启Redis持久化机制，尽快恢复缓存集群

再比如: 热点数据集中失效(比如每天0点的秒杀活动)

我们在设置缓存的时候，一般会给缓存设置一个失效时间，过了这个时间，缓存就失效了。对于一些热点的数据来说，当缓存失效以后会存在大量的请求过来，然后打到数据库去，从而可能导致数据库崩溃的情况。

1. 在设置失效时间的时候, 设置随机值(会使失效的时间均衡, 而不是在同一刻)
2. 互斥锁, 例如缓存击穿中说的. (会导致死锁)
3. 缓存上设置的key为永不过期, 逻辑上人为的修改. (会导致短暂的数据不一致)

# 总结:
对于在设置缓存时, 我们有三个目标需要考虑:
- 加快用户访问速度, 提高用户体验
- 降低后端负载, 减少潜在的风险
- 保证数据”尽可能“及时更新
