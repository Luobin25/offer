关于对索引的理解, 主要参照: [我以为我对Mysql索引很了解，直到我遇到了阿里的面试官](https://juejin.im/post/5d23ef4ce51d45572c0600bc)的问题进行的一些思考

索引它的实现方式有很多, 它的思想就好比如: 当你在看一本书,想了解大概意思的时候,你不需要一页页的翻(全表扫描), 你只需要通过目录(索引)就能找出你感兴趣的地方.

> Indexes are data structures that storage engines use to find row quickly

索引的类型有很多, 比较常见的是 B+树 和 哈希表. 索引其实就是一种数据结构, 所以没有说用了B+树,就不能用哈希表的(InnDB的自适应哈希表).根据你的具体情况,来选择才是最好的.

而且索引也不是一定需要的,只是大部分来说,索引是必要的. 就像一本书,如果书只有几页或几十页,这时候用全表扫描的形式既可以了. 如果书太大,大到你的手都抓不住,这时候分成卷一,卷二,卷三才更合适(分区思想)

## InnoDB 索引的数据结构
InnoDB索引使用的是B+树, 先来看两张图  
![B+ Tree](https://lh3.googleusercontent.com/proxy/mqFI587-mJLaKLCryAn5ftF3OSbz0lW991zMkFLuPmEC8E1CjuprKGtvLeeMZ8auwXgLBJ1khTqwMdkB164CqU_EQ2ntIX29VRJv91iLEowBjLH8XyWQsYicYeGoG2XMNJEV9D4)
![binary Tree](https://www.researchgate.net/profile/Jose_Amaral3/publication/221496921/figure/fig1/AS:305660496498688@1449886549536/A-binary-tree-with-15-nodes-The-node-number-indicates-the-order-in-which-the-node-was.png)

B+树延伸于二叉树, 二叉树的思想在于二分查找(举一个经典例子,猜数字(1~100). 如果次数无限, 我们大可以从1猜到100(100次). 但是我告诉你,我每猜一次, 我就能减少一半的数, 信不信? 不信的自行Google,333).  
二叉树通过左右节点的规则(即左节点的值永远小于根节点, 右节点的值永远大于根节点). 使得我们在查找的过程中, 对每一轮的查找,都能排除一半的数据量(O(logN).

那既然这样就挺好的呀,为什么还弄出B+树呢? 等等,那B树又是什么情况?

### 为什么不用二叉树? 什么是B树?
先来看二叉树和B树的区别, 二叉树只存在左右两个孩子.所以当**存的数量越多的时候,它的高度会越高**. 而B树又叫做 N叉树, N是我们自己可以定义的,如上图N等于三, 相当于三个孩子. 那么当它的N越来大的时候, 对于同样的数据集, N叉树的高度是不是就会比二叉树的小很多

对于SQL来说,其存储的数据量一定是巨大的,大到内存是放不下的(不然用它干嘛), 所以对于这样的树结构, 我们每读取一层,就相当于调用一次磁盘I/O. 那层数小的优势就体现出来了. 对于千万级的数据来说,通过调用B树, 只需要调用**三次I/O**就可以获取数组!!

那B树 和 B+树 的区别呢? B树非叶子节点存数据+指针, 而B+树只存键值+指针. 所以B+树的每一个非叶子结点,都能访问更多的数据. 第二, B+树的叶子节点是一个双向链表, 因为B+树的数据都是存在叶子节点的, 而且都是从到大排好序的, 那么通过了双向链表, 我们不仅能**等值查询, 还可以进行范围查询**, 这也是为什么B+树吸引人的地方.

提一句, B+树的插入涉及到旋转和拆分. 删除涉及到一个参数, `填充因子`. 当填充因子不足50%时, 会跟兄弟节点进行合并

## B+树和哈希的不同

- 哈希适合等值查询,不能用于范围查询.而B+树都可以
- 哈希索引数据并不是排好序的,而是随机存储(hash函数), 而B+树是顺序存储
- 哈希不适合最左匹配原则
- 某些极端情况下, 哈希可能存在大量冲突

# 聚簇索引, 辅助索引
只要你了解了B+树的这个结构, 那么对于这两个索引,你只需要考虑的是它们的值存的是什么, 或者它们叶子节点存的值是什么.对于InnoD来说, 一个表就相当于一个**聚簇索引**,因为其**非叶子节点存储的是主键, 而叶子节点存储的是每一行数据**. 而辅助索引,也就是我们自定义的索引(设置某列为索引), **非叶子存储的是该列的值, 叶子节点存储的是主键值**

这里有两点细节要补充:
1. B+树并不能找到一个给定值的具体行, 而是找到给定值的对应页. 因为B+树每个节点所含的内容大小等于InnoDB设置的页大小. 这样做的是好处是充分利用磁盘I/O.所以非叶子结点在页中存储的就是(大量的键值+指针), 而叶子结点存储的是一段连续的行. 然后数据库把该页读进内存后,再进行查找(所以,也告诉我们要尽可能利用顺序查找来提高性能)
2. 通过辅助索引进行查找时, 会涉及回表. 因为它存储的是主键时,例如 `select * from t where b = x` 通过b索引找到主键值, 再通过相应主键值找到该行.

## 覆盖索引
对于上面细节2, 针对某些查询, 我们可以优化到不需要回表.例如  `select a from t where b = x`, 因为我们查询的是索引b为x对应的主键值,而辅助索引存的正好是主键值, 所以我们就没必要回表了.

除此之外, 例如 `select count(*) from t`, 计算表的总行数. 数据库进行优化后, 会选择使用索引b来查询. 因为无论索引b或者索引a,两者的行数一样. 然后索引b存的是主键值, 索引a存的是行数据, 在遍历的过程肯定是b更快(如果不知道为什么, 思考下刚提到的InnoDB页)

## l



