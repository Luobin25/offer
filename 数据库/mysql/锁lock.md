InnoDB是面向事务的,所以当一个事务开启时, 我们可以操作的对象有: **表, 页, 行**. 当存在并发操作的时候, 这些被操作的对象就存在同时修改的风险, 我们需要设置一种机制,来避免同时修改导致的bug --> **锁**

## 两阶段锁
两阶段锁: 在一个事务开启后, 执行到相应的语句时,才会对被操作的对象进行上锁(不会提前上锁). 但所有的锁必须到commit或rollback时才会被释放掉.这就是两阶段的含义.  

为什么不能提前释放? 来看个例子
```
t表有两列,分别为a和b

Session A                                     SessionB
begin;
select b from t where a=1
  for update;
update t set b = 2 where
  a = 1;
                                      update t set b = 3 where
                                                a = 1;
    
select b from t where a=1
  for update;
```

如果A在执行完update后就释放掉该锁, 会导致它在进行一次查询时, 获取的值为3. (**违背了事务的一致性和隔离性**).

当我们不能提前释放锁的时候, 有个原则你就需要注意: **如果你的事务要锁多行, 把最可能造成锁冲突, 最可能影响并发性的锁尽可能放在最后执行**  
例子, 电影院买票过程:
1.查看用户余额
2.扣除用户余额
3.给平台账号添加余额

123 和 321 有区别吗? 答案是有的, 因为对于3的操作, 存在着锁冲突的风险(每个买电影票的人都需要向该账号添加余额), 所以要放到最后执行,尽可能减少锁占用的时间

## 锁的种类
我们知道事务的操作涉及表,页,行. 那么大多数的数据库都是围绕着这三个对象进行加锁的. MYISAM(表锁), InnoDB(行锁+表锁).

我们主要针对InnoDB进行分析

### InnoDB锁
行锁的粒度是最细的, 所以能最大的程度上执行并发操作, 但也会导致消耗的资源大, 而且还容易导致死锁  
表锁粒度粗, 消耗的资源小, 但并发操作会经常被阻塞,效果不好.

因为InnoDB是支持多粒度锁的(行锁和表锁), 那么就会存在一个问题:
- 事务A修改表中的某一行, 那么自然会对该行上锁(行锁)
- 事务B想修改表结构, 那需要对该表上锁(表锁)
如果B可以申请锁成功的话, 那理论上, 它能**修改表中任意一行, 这与A持有的行锁是冲突的**  
所以为了避免这种冲突, 需要进行两次判断
- 判断表是否已经被其他事务用表锁锁住
- 判断表中的每一行是否已经被行锁锁住..

对于第2个判断, 如果行数过大时,一个一个判断实在不是明知之举. 所以InnoDB推出了第三种锁: 意向锁

> Intention lock(意向锁) are table-level locks that indicate which tyoe of lock(shared or exclusive) a transaction requires later for a row in a table

意向锁是个表级别的锁, 它的用途在于: 当我们在拿行锁之前, 必须要先拿一个假的表锁,表示你想去锁住表里的某一行或者多行记录.(它代表着下一条语句的一种执行意向), 当mysql在申请表锁时,就不需要再去一行行查看了, 只需要看看, 有没有人拿了这个假的表锁

锁的类型: (shaard or exclusive)
有时候你会感觉为什么要弄这么多种锁, 而且还要有不同的类型. 但mysql一切都是为了能尽可能的加大并发.

操作事务对象,其实理念上跟操作一个变量是一样的. 对于一个变量来说, 我们肯定希望的是**读是共享的, 写是独占的**, 因为无论多少人读,它的值还是那样,所以当一个人读的时候,没必要阻塞别人(shared), 而写肯定是独占的(exclusive)

所以对于锁来说, 都存在两种锁, 共享锁和排他锁. 共享锁之间不互斥, 排他锁互斥, 排他锁和共享锁也互斥.

### 死锁检测
既然存在互斥,那就会有产生死锁的可能. 假设:
```
Session A                                     SessionB
begin;                                        begin;
update t set b = 1 where
  a = 1;
                                     update t set b = 2 where
                                                a = 2;
    
update t set b = 1 where
  a = 2;
                                      update t set b = 2 where
                                                a = 1;

```

A先对a为1的行加锁, B对a为2的行加锁. 当A想对a为2的行加锁的同时b也想对a为1加锁, 死锁就产生了. 

对于死锁, InnoDB提供了 **死锁检测**机制. InnoDB会主动的检测死锁,在发生死锁的时候,能够快速发现并进行处理(会对锁占有比较少的事务进行回滚),但是它也会造成额外的负担(**当一个事务锁住时,它需要查看它所依赖的线程有没有别人锁住, 如此循环,最后判断是否出现了循环等待,也就是死锁)

再来看,我们上面提到过 电影院买票的例子, 如果该电影院在某个时间段推出了半折购的优惠, 那就会造成会有大量的事务需要更新同一行的场景(热点行).
- 假设有1000个并发线程要同时更新同一行
- 每一个运行到该句被阻塞的线程就会自动进行死锁检测(每一个要循环检测1000个)
- 死锁检测操作是100万级别的(1000 * 1000)

需要通过控制并发度或者一些逻辑来(将该账户的值分成多行)减少死锁的检测

## MDL锁 元数据锁
我们虽然告诉大家InnoDB支持行锁和表锁,但在受到行锁如此之多的好处下, 是没必要使用表锁的. 那MDL锁又是什么呢? 先来看一个bug:
- 事务A正在遍历t表中的数据
- 事务B对t表结构做了修改,删除了一列
- 事务A再一次遍历时,发现结构不对,突然少了一列...

为了避免这种对元数据的修改(DDL语句)而造成的bug, MYSQL在5.5版本中引入了MDL, 它不需要显示使用,在访问一个表的时候会被自动机上. MDL的作用是,保证读写行.MDL是事务级别的, 只有在事务结束后才会释放.MDL不仅仅适用于表,同样也适用于其他对象(tablespace, schema, function, table, trigger等)

MDL也存在共享和排他锁, 对于所有的DML(增删改查语句)都会获得一个共享锁,而当使用DDL语句进行表结构修改时,需要获得一个排他锁

MDL锁会引发一个问题:
- 事务A查询t表的数据(获得MDL共享锁)
- 事务B查询t表的数据(获得MDL共享锁)
- 事务C要修改t的表结构(需要MDL排他锁, 被阻塞)
- 事务D查询t表的数据(需要MDL共享锁,被阻塞)

有人会问说为什么D会被阻塞,因为获取锁是一个队列模式, 前面的事务C被阻塞了, 后面自然的也要被阻塞.  
如果该表的查询语句非常频繁,再加上客户端的重试机制. 如果DDL执行的太久,会导致**这个库的线程很快就会饱满**

可以手动kill掉DDL语句或者设置一个定时器,超过多长时间就自动释放掉该锁

##
