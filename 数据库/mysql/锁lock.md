InnoDB是面向事务的,所以当一个事务开启时, 我们可以操作的对象有: **表, 页, 行**. 当存在并发操作的时候, 这些被操作的对象就存在同时修改的风险, 我们需要设置一种机制,来避免同时修改导致的bug --> **锁**

## 两阶段锁
两阶段锁: 在一个事务开启后, 执行到相应的语句时,才会对被操作的对象进行上锁(不会提前上锁). 但所有的锁必须到commit或rollback时才会被释放掉.这就是两阶段的含义.  

为什么不能提前释放? 来看个例子
```
t表有两列,分别为a和b

Session A                                     SessionB
begin;
select b from t where a=1
  for update;
update t set b = 2 where
  a = 1;
                                      update t set b = 3 where
                                                a = 1;
    
select b from t where a=1
  for update;
```

如果A在执行完update后就释放掉该锁, 会导致它在进行一次查询时, 获取的值为3. (**违背了事务的一致性和隔离性**).

当我们不能提前释放锁的时候, 有个原则你就需要注意: **如果你的事务要锁多行, 把最可能造成锁冲突, 最可能影响并发性的锁尽可能放在最后执行**  
例子, 电影院买票过程:
1.查看用户余额
2.扣除用户余额
3.给平台账号添加余额

123 和 321 有区别吗? 答案是有的, 因为对于3的操作, 存在着锁冲突的风险(每个买电影票的人都需要向该账号添加余额), 所以要放到最后执行,尽可能减少锁占用的时间

## 锁的种类
我们知道事务的操作涉及表,页,行. 那么大多数的数据库都是围绕着这三个对象进行加锁的. MYISAM(表锁), InnoDB(行锁+表锁).

我们主要针对InnoDB进行分析

### InnoDB锁
行锁的粒度是最细的, 所以能最大的程度上执行并发操作, 但也会导致消耗的资源大, 而且还容易导致死锁  
表锁粒度粗, 消耗的资源小, 但并发操作会经常被阻塞,效果不好.

因为InnoDB是支持多粒度锁的(行锁和表锁), 那么就会存在一个问题:
- 事务A修改表中的某一行, 那么自然会对该行上锁(行锁)
- 事务B想修改表结构, 那需要对该表上锁(表锁)
如果B可以申请锁成功的话, 那理论上, 它能**修改表中任意一行, 这与A持有的行锁是冲突的**  
所以为了避免这种冲突, 需要进行两次判断
- 判断表是否已经被其他事务用表锁锁住
- 判断表中的每一行是否已经被行锁锁住..

对于第2个判断, 如果行数过大时,一个一个判断实在不是明知之举. 所以InnoDB推出了第三种锁: 意向锁

> Intention lock(意向锁) are table-level locks that indicate which tyoe of lock(shared or exclusive) a transaction requires later for a row in a table

意向锁是个表级别的锁, 它的用途在于: 当我们在拿行锁之前, 必须要先拿一个假的表锁,表示你想去锁住表里的某一行或者多行记录.(它代表着下一条语句的一种执行意向), 当mysql在申请表锁时,就不需要再去一行行查看了, 只需要看看, 有没有人拿了这个假的表锁

锁的类型: (shaard or exclusive)
有时候你会感觉为什么要弄这么多种锁, 而且还要有不同的类型. 但mysql一切都是为了能尽可能的加大并发.

操作事务对象,其实理念上跟操作一个变量是一样的. 对于一个变量来说, 我们肯定希望的是**读是共享的, 写是独占的**, 因为无论多少人读,它的值还是那样,所以当一个人读的时候,没必要阻塞别人(shared), 而写肯定是独占的(exclusive)

所以对于锁来说, 都存在两种锁, 共享锁和排他锁. 共享锁之间不互斥, 排他锁互斥, 排他锁和共享锁也互斥.

### 死锁检测
既然存在互斥,那就会有产生死锁的可能. 假设:
```
Session A                                     SessionB
begin;                                        begin;
update t set b = 1 where
  a = 1;
                                     update t set b = 2 where
                                                a = 2;
    
update t set b = 1 where
  a = 2;
                                      update t set b = 2 where
                                                a = 1;

```

A先对a为1的行加锁, B对a为2的行加锁. 当A想对a为2的行加锁的同时b也想对a为1加锁, 死锁就产生了. 

对于死锁, InnoDB提供了 **死锁检测**机制. InnoDB会主动的检测死锁,在发生死锁的时候,能够快速发现并进行处理(会对锁占有比较少的事务进行回滚),但是它也会造成额外的负担(**当一个事务锁住时,它需要查看它所依赖的线程有没有别人锁住, 如此循环,最后判断是否出现了循环等待,也就是死锁)

再来看,我们上面提到过 电影院买票的例子, 如果该电影院在某个时间段推出了半折购的优惠, 那就会造成会有大量的事务需要更新同一行的场景(热点行).
- 假设有1000个并发线程要同时更新同一行
- 每一个运行到该句被阻塞的线程就会自动进行死锁检测(每一个要循环检测1000个)
- 死锁检测操作是100万级别的(1000 * 1000)

需要通过控制并发度或者一些逻辑来(将该账户的值分成多行)减少死锁的检测

## MDL锁 元数据锁
我们虽然告诉大家InnoDB支持行锁和表锁,但在受到行锁如此之多的好处下, 是没必要使用表锁的. 那MDL锁又是什么呢? 先来看一个bug:
- 事务A正在遍历t表中的数据
- 事务B对t表结构做了修改,删除了一列
- 事务A再一次遍历时,发现结构不对,突然少了一列...

为了避免这种对元数据的修改(DDL语句)而造成的bug, MYSQL在5.5版本中引入了MDL, 它不需要显示使用,在访问一个表的时候会被自动加上. MDL的作用是,保证读写行.MDL是事务级别的, 只有在事务结束后才会释放.MDL不仅仅适用于表,同样也适用于其他对象(tablespace, schema, function, table, trigger等)

MDL也存在共享和排他锁, 对于所有的DML(增删改查语句)都会获得一个共享锁,而当使用DDL语句进行表结构修改时,需要获得一个排他锁

MDL锁会引发一个问题:
- 事务A查询t表的数据(获得MDL共享锁)
- 事务B查询t表的数据(获得MDL共享锁)
- 事务C要修改t的表结构(需要MDL排他锁, 被阻塞)
- 事务D查询t表的数据(需要MDL共享锁,被阻塞)

有人会问说为什么D会被阻塞,因为获取锁是一个队列模式, 前面的事务C被阻塞了, 后面自然的也要被阻塞.  
如果该表的查询语句非常频繁,再加上客户端的重试机制. 一旦DDL执行的太久,会导致**这个库的线程很快就会饱满**

可以手动kill掉DDL语句或者设置一个定时器,超过多长时间就自动释放掉该锁

## 一个无法避免的问题,幻读
幻读: 对于两次查询语句,会产生不同的结果.(Ps: 读提交阶段产生的问题是: 对同一语句的两次查询,会产生不同的结果)  
来看个例子:  
```
CREATE TABLE `t` (
  `id` int(11) NOT NULL,
  `c` int(11) DEFAULT NULL,
  `d` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `c` (`c`)
) ENGINE=InnoDB;
insert into t values(0,0,0),(5,5,5),
(10,10,10),(15,15,15),(20,20,20),(25,25,25);

    Session A                                     Session B                          Session C
    begin;
select * from t where d = 5 for update  
                                              update t set d = 5 where id = 0
                                                                                  insert into t values(1,1,5)
select * from t where d = 5 for update 
    commit;
```
根据上文的加锁原理, 会话A只对id=5这行添加行锁. 所以会话B和会话C的操作是不会收到影响的. 有人会说, 一个是修改id=0和一个是插入, 不受到影响应该是正常的.  
但是它违背了事务的语义性, 事务A的本意是**”我要把所有id=5的行锁住, 不准别的事务进行读写操作“**  
再来看一个例子:
```
    Session A                                     Session B                          Session C
    begin;
select * from t where d = 5 for update
update t set d = 100 where d = 5
                                              update t set d = 5 where id = 0
                                                                                  insert into t values(1,1,5)
select * from t where d = 5 for update 
    commit;
```
事务提交的顺序是 事务b 到 事务c 再到 事务a. 所以在binlog上记录的是:
- update t set d = 5 where id = 0
- insert into t values(1,1,5)
- update t set d = 100 where d = 5
如果进行主从备份时, 从库上就多了三条d为100的数据. **数据的一致性**出现了问题
 
再来对幻读做个定义: 幻读指的是一个事务在前后两次查询同一个范围时, 后一次查询查到了前一次没有的结果
- 在可重复读隔离级别下, 普通的查询是快照读, 是不会看到别的事务插入的数据的. 所以幻读只会出现在“当前读下”(select ... for update)
- 幻读仅专指“新插入的行”(所以事务B修改还不能算)

## 间隔锁
针对上面的问题, 如果在会话A`select * from t where d = 5 for update`中对访问过的所有行进行加锁的话, 会话B会被阻塞, 但是会话C还是会执行成功. 因为会话C是新插入的一行,所以为了把C也阻塞住, 我们引用入 **间隙锁**

间隙锁:就是锁两个值之间的空隙, 如果一个表中只有2个主键行, 分别为5和10. 那它们的间隙为: *(负无穷, 5), (5,10), (10,正无穷)*.一般在加锁的时候,我们会把间隙锁和行锁合起来一起加, 简称 **next-key lock**, 每个锁均为左开右闭区间, 例如: *(负无穷, 5], (5,10], (10,正无穷]*  

间隙锁跟间隙锁不会产生阻塞, 它们的共同的目标是为了 **保护这个间隙不被使用**. 但你要知道间隙锁的引入, 可能会导致同样的语句锁住更大的范围,这会变相影并发度的,还加大产生死锁的可能.

例如:
```
session A                                       session B
begin;
select * from t where c=10 for update;
                                                begin;
                                                update t set d = d+1 where c = 10;
insert into t values(8,8,8)                   
                                                deadlock detect
```
其实`next-key lock`只是一种整合,方便理解. 实际上加锁的过程中还是分两步添加锁
- 会话A中select语句 对 c为10的行 加上 `next-key lock锁(5,10]`
- 会话B中update时, 先是加间隙锁(5,10), 再拿行锁时,阻塞
- 会话A插入语句时产生死锁(因为B也拿着间隙锁,导致A插入不了数据,需要等B释放, 而B需要等A释放)

注意: 间隙锁是为了解决幻读所出现的, 而对于幻读, 是RR隔离级别需要面临的问题, 对于RC级别(读提交)是不需要考虑间隙锁的.  
具体的加锁细节,算法. 参考 [何等成的加锁处理分析](http://hedengcheng.com/?p=771)

总结一下,锁的算法: 两个原则, 两个优化, 一个bug
- 原则1: 加锁的基本单位为`next-key lock`, 为前开后闭区间
- 原则2: 查找过程中访问到的对象才加锁
- 优化1: 索引上的等值查询, 如果是唯一索引, `next-key lock`锁会退化成行锁
- 优化2: 索引上的等值查询, 向右遍历时且最后一个值不满足值条件的时候, `next-key lock`退化成间隙锁
- 一个bug: 唯一索引上的范围查询会访问到不满足条件的第一个值为止

