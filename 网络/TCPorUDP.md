先想象两个场景: 
- 当你在看直播的时候,如果网络卡了一下, 导致有2s的画面没看到,你会生气吗? 如果过了1分钟, 它突然发给你之前丢失的2s画面,你觉得有必要吗?
- 当你在和喜欢的女生聊天,如果网络卡了一下,导致有一条短信没收到, 你会生气吗? 如果过了1分钟, 它给你发来那条丢失的短信,你觉度有必要吗?

看完这两个场景, 我们可以归纳为两个特点, 第一场景考虑的是数据的即时性(实时视频直播,游戏), 第二场景考虑的数据的完整性(聊天,传数据)

## UDP(User Datagram Protocol)
UDP 是一个`Connectionless`的协议, 也称面向数据的协议. 当应用层产生完数据后, 在UDP协议中它只添加了相应的一些包头(两端的端口,数据的长度,检验码),之后就直接发给网络层

![udp header](http://telescript.denayer.wenk.be/~hcr/cn/idoceo/images/udp_header.gif)

人们经常称UDP为`best-effort attempt delivery`, 尽一切可能往对端传输数据, 因为对UDP来说,它不需要设置TCP中的一大堆参数,以及建立连接什么的,应用端只要一产生数据,它就立马往对端发送.但这样也会产生后果,就我只负责发送数据,我不对数据进行标记,缓存.那么如果在路上的时候,数据丢失了,你别来找我,我是不负责的.这样也会衍生出它的一个特性,`应用层细粒度的控制`

总结一下(如果不清楚TCP的先往下看,再回来):
- Finer application-level control over what data is sent, and when  
除了一些流应用以外, 短连接的场合也是UDP比较受欢迎的, 因为对于短连接, 我可能只向对端发个一两次的数据,但要是使用TCP, 我就先建立TCP三次握手.这样会有点得不偿失, 但是短链接中,我又需要去保证数据的可靠性, 所以我们需要人为的在应用层添加一些机制  
业界比较著名的两个UDP改造协议: `RUDP`, `QUIC`(HTTP/3的协议)

- No connection established and states  
不需要像TCP那样进行三次握手,四次断开.不建立连接, 也就不需要去维护连接中的参数,状态. 如缓存池, 滑动窗口, 拥塞机制等

- 头部开支小, TCP头部为20字节, UDP为4字节

- 数据存在丢失风险,数据到达顺序不确定

- UDP的通信有界性  
UDP的通信是以数据包作为界限的，即使server端的缓冲区再大也要按照client发包的次数来多次接收数据包.即客户端分几次发送过来，服务端就必须按几次接收。

- 无法动态调整发包  
由于缺乏TCP类似的流和拥塞控制算法,导致当网路不稳定时, 它不会动态调整发送率,从而导致大量丢包.在丢包的时候,不合理的简单重传(应用层面的设置),会进一步导致重传风暴,进一步加剧网络的拥塞.更重要的是,UDP的**无秩序和自私性**,一个疯狂的UDP程序可能会导致这个网络的拥塞,挤压其他程序的流量带宽,导致所有业务质量都下降

它比较出名的两个应用为`DNS`, `DHCP`. 

## TCP
> 传输控制协议(Transmission Control Protocol)是一种面向连接的、可靠的、基于**字节流**的传输层通信协议, 其运行可划分为三个阶段: `连接创建`,`数据传送`,`连接终止`

要想理解TCP, 我们先不要从那些大框架,大概念去入手.我们从UDP的角度一步步去实现TCP

下面的例子均模拟单点传输, 即客户端向服务端发送数据.
### 0.UDP的传输
通过UDP的报文头部,我们知道
- 客户端应用层传递 *数据* 给传输层
- 传输层添加上UDP包头: 两端端口, 长度, 检验码 -> 形成数据段,segment
- 由于是无连接, 直接发送给服务端

存在问题: 两端之间的链路是不可靠的, 所以没有办法确认对端是否收到. 除此之外,假设我们保证链路是一定可靠的, 但是我们也没办法保证数据是可靠的,即服务端收到的数据是否等同于客户端发出的

### 1.ARQ(Automatic Repeat reQuest)
假设你和你的上司或下属打电话, 那么最常用两个词: **“OK” and “Repeat”**. 因为通过这两个词, 就能告知对方,我们是否理解了.对于机器也一样, 我们在服务器上添加一个新功能,对于每次收到的数据包基于回复,回复的类型有两种,`positive acknowledgments` 和 `negative acknowledgments`

通过ARQ,我们解决了 数据确认和数据重传 的问题.  
但是我们只是简单的添加 `OK` 和 `Repeat` 会导致我们所有的数据都是串行的, 每一个数据,发送方都需要等待接受到回复消息后才进行下一步的操作

这就是著名的**stop-and-wait protocol**

存在问题: 你是否有考虑连回复消息都被腐蚀或者修改了呢?我们又如何确保回复消息的正确性呢?  
我们来考虑看看以下三种可能性:
- 添加第三种词,比如“你再说一次”, 让对方在发送一次ARQ. 但是这样的解决又会牵连出比如第三种词是否也存在被修改的可能?(这条路是永无止境的)
- 增加足够多的检验码. 从根本上解决问题
- 发送方再发一次, 这里会导致一个问题,接收方无法清楚这是重新发过来的,还是新的

### 2. Sequence Number(序列号)
通过对发送的数据包和回复的数据包添加序列号, 就能解决上面的问题.  
当发送方接受到期望收到的ACK后,就接着转发下一条数据.同时, 我们可以使用`positive ack`来代替`negative ack`,因为我们对每个包都打上了序列号,假设
1. client发送一个序列号为3的包
2. server接收到后,发现包损坏.回复一个序列号为2的ACK(代表它目前收到最新的数据包是2)
3. client接收到后,发现ACK为2不为3.重新发送3
4. (注意,这里忽略了网络延迟的可能性, 对于现实网络, 发送方如果多次接受到同一个数据包的ack,即dupicate ack后,才能确定后面的数据包损坏了)

### 3. 定时器
其实对于计算机网络来说, 大家担心的无非两个问题: **怎么检测丢包** 和 **丢包以后该怎么做**. 我们通过使用`检验码`,`ACK`,`序号`,`重传`已经解决了后一个问题.

对于前者呢, 我们启用了一个新策略 **定时器**, 从第一次发送新的数据包后,如果定时器超时,那么发送端又会再一次发送该数据包

### 收尾:
到目前为此, 通过以上的技术,我们就可以实现一个可靠的的**数据同步传输协议**(特意加同步是因为它为`stop-and-wait protocol`协议)

剩下的留到下一篇在描述
