# HTTP的连接演化

## 早期版本
早期版本(HTTP 0.9, HTTP 1.0)的时候,对于每一个请求,都会创建一个连接(TCP).可是我们知道访问一个网页时,不单单访问它自身,还需要加载各种静态资源和各种API调用.  
如果一个请求,客户端需要和服务端建立大量连接,这是非常耗费资源的.因为TCP连接要建立三次握手,同时根据拥塞算法,一开始要`慢启动(slow start)`

## 1.1中的持久连接
1.1算是一个久经不衰的版本了. 它在1.0的版本上引入了持久连接(persistentce connect)

```
如果你进行抓包的话,会默认发现一个参数

Connection: keep-alive
```
它用于告诉服务器,当传输完一个请求之后,不要立马关闭连接,以便其他请求复用.

客户端和服务器发现对方一段时间没有活动,就主动关闭该连接.不过,规范的做法是客户端在最后一个请求发送`Connection: close`，明确要求服务器关闭TCP连接。

## 1.1中的管道化
除了持久连接,另一个机制是引用了`pipelining`,管道化.持久连接只是复用这次TCP连接,但本质上还是需要一个请求完成后再到下一个请求.

通过管道化机制, 浏览器可以将多个`HTTP`请求整批提交,在发送过程中不需要先等待服务器的回应.

![pipeline](https://user-gold-cdn.xitu.io/2019/5/21/16ad9415ebab724b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

看到你这里,你肯定会说这个技术不错,极大的提升了HTML网页动态加载时间,但是如果我告诉你,现在这个技术被弃用了,你会不会很惊讶?

### 队头阻塞
尽管你这边能一次发的多了, 但是对于服务端,它必须按照顺序来一个个进行处理.比如你发了request1,request2, request3. 那服务端的返回顺序也是这个.

如果这时, request1的某部分的数据包丢失了.这时候根据TCP的原则,会超时重传.那你request2和request3就遭殃了.比如这三个请求中(request1是html网页,其他两个是小图片).  
原本我们可以先加载这两个小图片,但现在不得不要等待request1的重传.这就是 ***队头阻塞(HOL block)***

同时管道化的机制,只能对请求是幂等性的method才生效

## HTTP 2.0
参考 [HTTP/2 相比 1.0 有哪些重大改进？ - 知乎](https://www.zhihu.com/question/34074946)

包括:
- 二进制格式
- 数据流
- 多路复用
- 头信息压缩
- 服务端推送

摘自一些转载:  
帧：HTTP/2 数据通信的最小单位消息：指 HTTP/2 中逻辑上的 HTTP 消息。例如请求和响应等，消息由一个或多个帧组成。

流：存在于连接中的一个虚拟通道。流可以承载双向消息，每个流都有一个唯一的整数ID。

HTTP/2 采用二进制格式传输数据，而非 HTTP 1.x 的文本格式，二进制协议解析起来更高效。 HTTP / 1 的请求和响应报文，都是由起始行，首部和实体正文（可选）组成，各部分之间以文本换行符分隔。HTTP/2 将请求和响应数据分割为更小的帧，并且它们采用二进制编码。

HTTP/2 中，同域名下所有通信都在单个连接上完成，该连接可以承载任意数量的双向数据流。每个数据流都以消息的形式发送，而消息又由一个或多个帧组成。多个帧之间可以乱序发送，根据帧首部的流标识可以重新组装。

## HTTP 3.0(QUIC)
使用了UDP作为底层传输,,其中有个原因是为了解决**队头阻塞(TCP层面的)**


参考:  
[HTTP 协议入门 - 阮一峰的网络日志](http://www.ruanyifeng.com/blog/2016/08/http.html)
[扩展 · http2讲解](https://ye11ow.gitbooks.io/http2-explained/content/part7.html)
